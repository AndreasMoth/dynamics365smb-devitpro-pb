---
title: "Record.SetCurrentKey(Any [, Any,...]) Method"
description: "Selects a sort order on a table."
ms.author: solsen
ms.custom: na
ms.date: 11/10/2023
ms.reviewer: na
ms.suite: na
ms.tgt_pltfrm: na
ms.topic: reference
author: SusanneWindfeldPedersen
---
[//]: # (START>DO_NOT_EDIT)
[//]: # (IMPORTANT:Do not edit any of the content between here and the END>DO_NOT_EDIT.)
[//]: # (Any modifications should be made in the .xml files in the ModernDev repo.)
# Record.SetCurrentKey(Any [, Any,...]) Method
> **Version**: _Available or changed with runtime version 1.0._

Selects a key for a table.


## Syntax
```AL
[Ok := ]  Record.SetCurrentKey(Field1: Any [, Field2: Any,...])
```
## Parameters
*Record*  
&emsp;Type: [Record](record-data-type.md)  
An instance of the [Record](record-data-type.md) data type.  

*Field1*  
&emsp;Type: [Any](../any/any-data-type.md)  
  
*[Optional] Field2*  
&emsp;Type: [Any](../any/any-data-type.md)  
  


## Return Value
*[Optional] Ok*  
&emsp;Type: [Boolean](../boolean/boolean-data-type.md)  
**true** if the operation was successful; otherwise **false**.   If you omit this optional return value and the operation does not execute successfully, a runtime error will occur.  


[//]: # (IMPORTANT: END>DO_NOT_EDIT)

## Example (robust coding)

When writing AL code, you should always assume that calls to **SetCurrentKey** might fail. Use the following code snippet to write robust AL code that doesn't break if table keys change.

```AL
    var
        MyRecord: Record MyTable;
    begin
        if not MyRecord.SetCurrentKey(Field1, Field2) then
          // handle if no key was found 
```


## Remarks

You can use SetCurrentKey to hint a sort order to the [!INCLUDE[prod_short](../../includes/prod_short.md)] server. With the fields suggested in SetCurrentKey, the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will then search available key definitions and add an ORDER BY clause with the fields from the key to the SQL statement issued to the database. 

When you use SetCurrentKey the following rules apply:  

- Obsolete fields and flowfields are ignored. 

- Only active keys are considered. 

- When searching for a key, the first occurrence of a key that starts with the specified fields is selected. This means the following:  

  - Fields that are part of a **IncludedFields** definition aren't used when searching for a matching key.

  - If you specify only one field as a parameter when you call SetCurrentKey, the key that is actually selected may consist of more than one field.  

  - If the field that you specify is the first component of several keys, the key that is selected may not be the key that you expect.  

  - If no keys can be found that include the fields that you specify, the return value is **false**.


## Example - successful SetCurrentKey call

Assume that you have the following table with keys defined:

```AL
table 50100 MyTable
{
    fields
    {
        field(1; Field1; Integer)
        {
        }
        field(2; Field2; Integer)
        {
        }        
        field(3; Field3; Integer)
        {
        }
        field(4; Field4; Integer)
        {
        }

        field(5; ObsoleteField; Integer)
        {
            ObsoleteReason = 'Not used anymore';
            ObsoleteState = Pending;
            ObsoleteTag = '42';
        }
    }

    keys
    {
        key(Key1; Field1, Field2) 
        {
        }

        key(Key2; Field3, Field1, Field2)
        {
        }

        key(Key3; Field1, Field2, Field4)
        {
        }

        key(Key4; Field1, Field2)
        {
            IncludedFields = Field5;
        }
    }
}
```

In AL code, you then use the SetCurrentKey method to imply your preferred sort order of the data:

```AL
    procedure MyDataProc()
    var
        MyRecord: Record MyTable;
    begin
        if not MyRecord.SetCurrentKey(Field1, Field2) then
          // handle if no key was found 

        if not MyRecord.Find then
          // handle no records
        
        // more code here
    end;
```

In the code example above, the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will search for a key that starts with the fields **Field1** and **Field2**. For the table **MyTable** defined above, two such keys exist: **Key1** and **Key3**. It's not deterministic which of the keys the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will use. For illustration, assume that the [!INCLUDE[prod_short](../../includes/prod_short.md)] server picks **Key3**. The SQL statement generated by the [!INCLUDE[prod_short](../../includes/prod_short.md)] will then look something like this:

```SQL
SELECT Field1, Field2, Field3, Field4, Field5
  FROM MyTable
 // this ORDER BY clause is added by the Business Central server due to the SetCurrentKey call 
 // assuming that the server picks Key3  
 ORDER BY Field1, Field2, Field4
```

Note that in the end, the SQL query optimizer might choose not to use the index corresponding to **Key3**, if it determines that it can get a faster execution plan without using the index.


## Example - unsuccessful SetCurrentKey call without a runtime error

Assume that you have the MyTable table as defined above.

The following example illustrates the behavior of SetCurrentKey if no keys can be found.

```AL
    procedure MyDataProcNoKeyFound()
    var
        MyRecord: Record MyTable;
    begin
        if not MyRecord.SetCurrentKey(Field4) then
          // handle if no key was found 

        if not MyRecord.Find then
          // handle no records
        
        // more code here
    end;
```

In the code example above, the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will search for a key that starts with the field **Field4**. For the table **MyTable** defined above, no such key exist. The [!INCLUDE[prod_short](../../includes/prod_short.md)] server will return false, but will still add an ORDER BY clause and will not raise a runtime error. In this case, the SQL statement generated by the [!INCLUDE[prod_short](../../includes/prod_short.md)] will then look something like this:

```SQL
SELECT Field1, Field2, Field3, Field4, Field5
  FROM MyTable
 // this ORDER BY clause is added by the Business Central server due to the SetCurrentKey call 
 // assuming that the server could not find any key
 ORDER BY Field4
```


## Example - unsuccessful SetCurrentKey call with possible runtime error

Assume that you have the MyTable table as defined above.

The following example illustrates the behaviour of SetCurrentKey if no keys can be found and if the SetCurrentKey was using a field that is not supported in SetCurrentKey (in this case a field that has been obsoleted).

```AL
    procedure MyDataProcNoKeyFound()
    var
        MyRecord: Record MyTable;
    begin
        if not MyRecord.SetCurrentKey(ObsoleteField) then
          // handle if no key was found 
          // VERY IMPORTANT AS IN THIS CASE, THE SERVER WILL RAISE A RUNTIME ERROR

        if not MyRecord.Find then
            // handle no records
        
        // more code here
    end;
```

In the code example above, the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will search for a key that starts with the field **ObsoleteField**. For the table **MyTable** defined above, the field is obsoleted and the [!INCLUDE[prod_short](../../includes/prod_short.md)] server will return **false**. The [!INCLUDE[prod_short](../../includes/prod_short.md)] server will not add an ORDER BY clause in this case and will raise a runtime error (that will surface to the user if not handled). In this case, the SQL statement generated by the [!INCLUDE[prod_short](../../includes/prod_short.md)] will then look something like this:

```SQL
SELECT Field1, Field2, Field3, Field4, Field5
  FROM MyTable
 // no ORDER BY clause added by the Business Central server due to the SetCurrentKey call 
```


## See Also
[Record Data Type](record-data-type.md)  
[Get Started with AL](../../devenv-get-started.md)  
[Developing Extensions](../../devenv-dev-overview.md)  
